优化

+ 输入起始站，终点站，如果没票了，提供中转功能？
+ 票价计算比较简单，实际票价是每一段区间距离多少钱，而不是固定的多少钱多少公里
+ 乘客类型（学生、军人、普通人）



### 数据库表

**车站表**：车站名的信息

**车次表**：车次编号(G1、G2…)，车次类型(G、D、K)，起始站，终点站

+ 车次类型是一个枚举类（车次类型，描述，票价）

+ ```java
  
      G("G", "高铁", new BigDecimal("1.2")),
      D("D", "动车", new BigDecimal("1")),
      K("K", "快速", new BigDecimal("0.8"));
  ```

+ 数据库里面存储的是第一个字段

**车厢表**：车次编号(关联车次用的)，车厢号(从1开始)，座位类型(一等座、二等座、硬卧、软卧)，座位数，排数，列数

+ 座位类型是个枚举，座位类型确定了一排有多少个座位

+ ```java
   YDZ("1", "一等座", new BigDecimal("0.4")),
      EDZ("2", "二等座", new BigDecimal("0.3")),
      RW("3", "软卧", new BigDecimal("0.6")),
      YW("4", "硬卧", new BigDecimal("0.5"));
  ```

+ 数据库里面存储的是第一个字段

**座位表**：车次编号（关联车次用的）， 车厢号（关联车厢用的），排号（第几排，01，02，03…）,列号(A,B,C,D,F)，

座位类型，座位序号(第几个座位，索引，1…座位数量)



模块拆分

主模块、公共模块、member模块

+ maven父子依赖
+ 公共抽取

全局唯一id生成

+ 雪花算法，生成自增的id（1位符号位（0） +  41位时间戳 + 10位机器号 + 12位序列号）

遇到的问题：axios跨域问题，按照网关配置了，但是还是出现跨域。



两种登录方式

+ redis + token
+ jwt

给定车型自动生成座位

数据库表

+ 火车站表
+ 火车车次
+ 火车车站（途径哪些车站）
+ 火车车厢

定时任务框架quartz

根据基础数据生成车次的一些信息（车站、车厢、车座位、余票）每一个生成数据的操作都需要加事务

使用的是一个方法调用生成数据的那些方法，可以只在这个方法加上事务就可以了（spring事务的传播性）





### 生成车票信息功能

生成某个车次某天的车票信息。

需要遍历这个车次经过的所有站，比如经过ABCD四个车站，我们就要生成AB AC AD BC BD这些区间的所以车票信息。

根据车次查询出所有的车站信息，使用两个for循环遍历出所有的车站之间的车票。

车票的余票数量

+ 查询出每个座位类型的座位数量

+ 如果一趟列车没有该座位类型，后端可以将这个座位数量设置为-1，表示没有这种类型的座位，不要设置为0，因为0可能会误以为被卖光了。

车票价格计算

+ 根据距离，车的类型（高铁，动车，火车），座位的类型（一等座、二等座、软卧、硬卧）计算出车票价格

车票预定功能

+ 选座依据
  + 都是一等座或二等座才支持选座
  + 余票小于20不支持选座

![image-20240111105437241](https://note-1322176778.cos.ap-guangzhou.myqcloud.com/java/juc/image-20240111105437241.png)

站序是从0开始，第一站是0

扣减车票

![image-20240113213519757](https://note-1322176778.cos.ap-guangzhou.myqcloud.com/java/juc/image-20240113213519757.png)

redis作为缓存

+ 基于内存，速度快
+ 解决数据共享

分布式锁的时间不够的话就会导致业务代码没有执行完，就会主动释放锁从而导致别的线程拿到锁，还是会出现并发问题。





redis缓存（缓存车票）

分布式锁（解决超卖问题）

分布式事务（seata）

## 黑马点评

全局唯一id生成策略

+ 使用时间戳+ redis自增
+ UUID
+ 雪花算法

库存超卖问题

什么时候使用乐观锁好，什么时候使用悲观锁好。

+ 乐观锁
+ 悲观锁

一人一单

+ synchronized （控制锁的粒度）

+ 本类方法事务不能生效：1.创建新的类 2.AopContext获取当前对象的反向代理对象

手动实现分布式锁

使用redisson分布式锁