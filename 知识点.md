

**Java**

+ `0.1 + 0.2 != 0.3`(浮点数如何存储？原码反码补码？`Java`如何解决这个问题？)    

  (**小林图解系统**)

枚举类

## JVM



## 并发编程

应用

+ 先打印2再打印1
+ wait &notify; park & unpark ; await & signal
+ 交替打印 5次abc(abcabcabcabcabc) 
  + wait &notify; park & unpark ; await & signal



三种创建实现线程的方式

+ 继承Thread类，重写run方法
+ 实现Runnable接口
+ 使用FutureTask类

**查看进程线程的方法**

**线程的状态**

+ 操作系统层面
  + 新建、就绪、阻塞、运行、终止
+ java api 层面
  + new、Runnable、Wating、TimeWating、Blocked、TERMINATED

线程上下文切换的原因

+ CPU时间片用完了
+ 垃圾回收，stop the word， 所有用户线程暂停
+ 有更高优先级的线程运行
+ 线程自己调用了 sleep、yield、wait、join、park、lock 等方法

变量的线程安全分析

线程安全的类



原子类

+ 有哪些原子类，用法，底层怎么实现的
+ LongAdder源码（CPU缓存一致性的问题，解决CPU伪共享）
+ LongAccumulator
+ Unsafe对象

享元模式：连接池复用

线程池

+ 线程池使用
+ 线程池参数
+ 有哪些线程池

park & unpark原理

synchronized原理

synchronized加锁流程（偏向锁、轻量级锁、重量级锁）**要更深入**（**浏览器收藏的博客**）

+ 偏向锁，自始至终只有一个线程竞争锁，对象MarkWord存储的是线程的地址值，才会使用偏向锁

  + 偏向锁撤销的条件

+ 轻量级锁，两个线程加锁，但不能发生竞争，对象的MarkWord记录的是锁记录地址值。

  线程会在栈帧中创建一个锁记录，对象的MarkWord尝试CAS将对象的MarWord替换成锁记录的地址值。

  CAS失败了有两种情况，一是发生了锁重入，二是发生了有竞争，就会进行锁升级，升级为重量级锁。

+ 重量级锁，两个线程以上，存在竞争。锁对象关联一个Monitor对象，Monitor的owner会记录获得当前锁的线程地址值，为了避免阻塞带来的巨大消耗，其他线程会进入_cxg链表中（后进先出），尝试自旋操作，自旋失败后会进入阻塞队列。

+ 自旋操作一定是在重量级锁进行的。

**AQS**

+ 利用AQS自己实现一个不可重入锁

+ 底层原理

ReentrantLock

+ 怎么用
+ 特点
+ 原理（读锁、写锁、公平、非公平、可重入、可打断、支持多个条件变量）



**CopyOnWriteArrayList**（书）

+ 线程安全的`ArrayList`
+ 使用
+ 原理(add、remove、set、迭代器的弱一致性)

**CopyOnWriteArraySet**

+ 线程安全的set集合

+ 底层使用的还是`CopyOnWriteArrayList`，进行了去重操作

**ThreadLocal**

+ 每个Thread类中有一个ThreadLocalMap，ThreadLocalMap的entry的key是ThreadLocal对象，弱引用对象，value是强引用。
+ 当ThreadLocal对象的引用不再使用了，进行垃圾回收，弱引用对象就会被回收，value是强引用，不会被回收，就会导致内存泄漏。
+ 可以在不使用了的情况下，主动调用remove()方法
+ 使用弱引用好处就是，key会为回收为null,当key为null时，如果使用ThreadLocalMap的set,get,remove，发现key为null，会将value也置为null

**ReentrantLock**



## MySQL

+ 基本`SQL`语句熟练

+ 一条Select语句执行流程

+ 数据行如何存储

+ 数据页如何存储的（数据页格式+ B+树如何查询的）

+ 索引

  + 索引数据结构（不同存储引擎支持什么类型的索引）

  + `MySQL`为什么用B+树？与B树、红黑树、平衡二叉树、二叉排序数区别

    MySQL数据是持久化的，数据存储在磁盘，读写数据需要去磁盘读写，磁盘I/O很慢，尽可能减少磁盘io，树的高度问题。

    MySQL支持范围查询，范围查询更快

    二叉排序树，可能会出现一条链表形式，平衡二叉树可以左右旋转，进行平衡，数据量太大的话，高度仍然很高

    B树每个节点都存数据（索引+ 记录），记录太大会导致查询时获得的数据个数就少，进行更多的io，

    范围查询b树使用中序遍历，b+树可以根据叶子节点左右查询（双向有序链表）

  + B树相对于B+树有什么好处呢？单点查询的时候，访问节点距离根节点很近会更快

  + 索引的分类（按数据结构分，按数据存储分，按字段特性分，按字段个数分）

  + 优化索引方法

  + 索引失效

    

  + count(`*`)、count(1)、count(主键)、count(字段) 区别？ 如何优化count(*)？

    （**`MySQL`45讲14讲**）

+ 锁

  + 全局锁
  + 表级锁
  + 行级锁

+ 事务

  原子性、持久性、隔离性都保证了，就能保证数据的一致性。

+ InnoDB存储引擎

  + bufferpool

+ 日志

  + redo log undo log bin log

## Redis

### 1. 持久化（AOF和RDB）

AOF保存的是操作的命令，RDB保存的是二进制数据。

+ AOF的风险：两点

  + 先执行命令再写AOF，这个步骤是两个过程，可能导致数据丢失
  + 写AOF和命令使用的都是主线程的话，写AOF可能会导致下一条命令的阻塞。

+ AOF写硬盘策略：三种

  + 写入AOF缓冲区，系统调用写入内核缓冲区，写入磁盘的时机由操作系统决定

+ AOF重写机制（后台重写策略）

  + 子进程重写，父子进程共享内存数据（只读）如果父进程修改了，就会发生写时复制。
  + 重写主线程发生修改，导致数据不一致。修改后的命令写入AOF重写缓冲区。

+ RDB

  发生数据丢失：进行RDB的时候主进程修改了数据，修改后的数据只能交给下一次RDB，这个时候发生宕机，修改的数据就会丢失。

+ 混合使用

  + 前半部分RDB，后半部分AOF，数据加载更快，数据更少丢失。

### 2. Redis大key对持久化的影响？ 

### 3. Redis数据类型和数据结构

+ 数据结构
+ 数据类型和应用场景
  + String
  + List
  + Hash
  + Set
  + ZSet
  + BitMap
  + GEO
  + Stream



### 4. 过期删除策略和内存淘汰策略 

过期删除策略
+ 定期删除
+ 定时删除
+ 惰性删除

内存淘汰策略
+ 8种
+ LRU和LFU的实现

### 5. 缓存相关

结合代码实际如何解决

缓存雪崩、缓存击穿、缓存穿透？

数据库和缓存如何保证数据的一致性？

### 6. Redis线程模型

redis是单线程么？

redis单线程模式？

redis为什么这么块？

+ 基于内存
+ 单线程避免线程的切换，不会导致死锁
+ 采用了IO多路复用技术 
  + select、poll、epoll区别

### 7. 主从复制

### 8. 哨兵

### 9. 集群

### 10. Redis事务



**SQL语句**

+ null值不能与数字进行比较，应使用is null 、is not null；去重distinct

+ 求字符串长度函数 char_length

+ 时间函数，求两个日期直接差值`datediff()`

+ round函数，保留小数点后几位。round(x, y)  y > 0，x保留小数点后y位； y < 0 从x的个位开始数y个数，进行四舍五入。

+ mod函数，求余操作，mod(a, 2) a对2求余

## Spring 

（Javaguide）

### 1. 什么是IOC？对于ioc的理解？IOC和DI区别?

ioc就是一个map集合存放一堆实例bean

### 2. AOP

AOP的理解

多个切面如何控制执行顺序？

+ @order注解（值越小优先级越高）
+ 实现Ordered接口重写`getOrder`方法

应用场景

+ 日志打印
+ @Transactional注解

AOP的实现方式

+ JDK的动态代理 Proxy类
+ Cglib
+ 两种的区别？

AOP和AspectJ的区别

+ Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 
+ Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作。
+ 增强功能比较多使用AspectJ

AOP的通知类型

+ 前置@Before
+ 后置@After
+ 环绕@Around
+ 异常通知@AfterThrowing
+ 返回通知@AfterReturning

### 3. 依赖注入的两种方式

setter方法注入
+ bean 的name属性与set方法去掉set后的第一个子母小写一样

构造方法注入 
+ bean 的name属性必须与构造方法的参数一样

### 4. bean注解相关

+ 常用的注解有哪些？

+ @Autowired 和 @Resource 的区别是什么？

+ @Component 和 @Bean 的区别是什么？

### 5. bean的作用域

使用@Scope注解配置作用域

作用域范围有：

+ **singleton** : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。
+ **prototype** : 每次获取都会创建一个新的 bean 实例。也就是说，连续 `getBean()` 两次，得到的是不同的 Bean 实例。
+ **request** （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。
+ **session** （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。

### 6. bean 是线程安全的吗？

多例是线程安全的，因为每次创建的bean都是新的对象。

单例bean的话就要看这个对象的成员变量是否线程安全。

哪些变量是线程安全，哪些不是线程安全？

+ 成员变量和静态变量
  + 没有被共享，线程安全
  + 被共享，但是只有读操作，也是线程安全的，有写操作，线程不安全

+ 局部变量
  + 局部变量是线程安全的
  + 但局部变量的引用就不一定
    + 如果局部变量引用逃离了方法的作用范围，可能会线程不安全
    + 没有逃离方法作用范围，线程安全

线程不安全的解决方法

+ 避免使用可变的变量

+ 使用ThreadLocal

### 7. bean的生命周期



### 8. spring使用到的设计模式



spring事务

+ 事务的传播性

spring循环依赖问题

springboot自动装配原理

+ 通过spring去读META-INF/spring.factories中保存的配置类文件然后加载bean
+ 如果是标了@Configuration注解，就是批量加载了里面的bean定义
+ 如何实现”自动“：通过配置文件获取对应的批量配置类，然后通过配置类批量加载bean定义，只要有写好的配置文件spring.factories就实现了自动。

## 设计模式

+ 单例模式

+ 工厂模式
+ 装饰器模式（IO流中有用到）
+ 代理模式（使用动态代理，AOP用到）
