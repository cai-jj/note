## 普通索引和唯一索引怎么选

从查询语句和更新语句的性能进行分析

## 查询过程

唯一索引查找到第一个记录就会停止向下查找，而普通索引会查找到符号条件的会就行向下查找，直到条件不符合。
MySQL读写都是按页(16K)为单位的，如果查找的记录是数据页最后一个记录，那么对于普通索引来说，需要继续读取下一个数据页，

但是每个数据页有近千个记录，这种出现的概率比较低。

性能差距：微乎其微

## 更新过程

更新数据页时，当数据页在内存中，就直接更新数据页；

如果不在内存中，在不影响数据的一致性的时候，先将更新的操作记录在change buffer里面，在需要查询这个数据的时候将这个数据页读入内存中，再执行change buffer里记录的操作。

**更新的数据所在的数据页在内存中进行插入数据操作**

+ 普通索引：找到位置插入元素
+ 唯一索引：找到位置，判断是否冲突，插入元素

多了一个判断，几乎没有区别

**更新的数据所在的数据页不在内存中的插入数据操作**

+ 普通索引：将更新操作记录在change buffer里面
+ 唯一索引：需要将数据页读入内存，判断这个值是否冲突

## change buffer的使用场景

写多读少的情况使用change buffer，将更新操作记录在change buffer里面，等到后续需要查询该数据时，从磁盘中读入内存

如果更新了之后里面进行查询，就需要去磁盘中读取对应的数据页，那么change buffer就没有意义了，还需要花费维护change buffer的代价。

redo log 与 change buffer的不同

主要在于在于优化了整个变更流程的不同阶段。 先不考虑redo log、change buffer机制，

简化抽象一个变更(insert、update、delete)流程： 

+ 1、从磁盘读取待变更的行所在的数据页，读取至内存页中。
+  2、对内存页中的行，执行变更操作 
+ 3、将变更后的数据页，写入至磁盘中。 
+ 步骤1，涉及 随机 读磁盘IO； 步骤3，涉及 随机 写磁盘IO； 

Change buffer机制，优化了步骤1——避免了随机读磁盘IO 

Redo log机制， 优化了步骤3——避免了随机写磁盘IO，将随机写磁盘，优化为了顺序写磁盘(写redo log，确保crash-safe) 

在mysql innodb中， change buffer机制不是一直会被应用到，仅当待操作的数据页当前不在内存中，需要先读磁盘加载数据页时，change buffer才有用武之地。 redo log机制，为了保证crash-safe，一直都会用到。 