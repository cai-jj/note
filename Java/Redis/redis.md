# Redis知识点

## 1.Redis数据结构

### 1.1 Redis数据结构

### 1.2 Redis数据类型

底层实现

应用场景

## 2. Redis如何保证持久化

AOF日志和RDB快照

### 2.1 AOF

每执行一条写命令，就会把命令写入AOF 文件里面

### 2.2 RDB

## 3.Redis 过期删除策略和内存淘汰策略

删除策略

key过期时间都存放在一个dict，通过dict判断一个key是否过期

+ 惰性删除
  + 访问到才会删除
+ 定时删除
  + 设置一个定时事件，到达时间就触发时间进行删除。
+ 定期删除
  + 定时抽取一定数量的数据进行检查，如果超过1/4的key过期就继续抽查，一直循环。循环时间也有限制（25ms）

内存淘汰策略

+ LRU
  + 并非使用传统的LRU算法，传统的每次LRU访问后需要将该节点移动到链表头节点。大量节点移动耗时，redis为每个对象添加了一个24bit 的lru字段，用来记录当前被访问的时机戳。每次随机选五个数据，淘汰最久没有被使用的数据。

+ LFU
  + lru前16位记录的是时间，后8位记录的是访问频率。
  + 访问频率并不是简单的增加，根据距离上一次访问的时间进行衰减（时间越长，衰减越多），然后进行增加（值越大越难增加）

## 4. Redis事务

### 4.1 事务相关命令

`MULTI` 开启一个事务

`EXEC` 提交事务

`DISCARD` 取消一个事务块，清空事务队列，并恢复到正常执行模式

`WATCH` 监视一个或多个Key，以确保在事务执行期间这些Key的值没有发生变化，如果被监视的Key被修改，那么事务将被中断

`UNWATCH` 取消对所有Key的监视

### 4.2 事务的实现

1.事务开始

通过MULTI命令开启事务

2.命令入队

执行完MULTI命令后，后续的命令会被放入一个队列中，该队列是一个数组类型

3.事务执行

通过EXEC执行事务，执行队列中的所有命令

### 4.3 WATCH命令的实现

本质是一个乐观锁，监视一个或多个Key，以确保在事务执行期间这些Key的值没有发生变化，如果被监视的Key被修改，那么事务将被中断。

监视的数据都保存在一个watched\_keys字典里面，字典的值是一个链表，保存的是一个个被监视的客户端

当执行对数据库修改的命令之后，会调用touchWatchKey函数对watched\_keys字典进行检查，如果CAS标识打开，则拒绝提交事务

### 4.4 ACID特性

原子性：

命令加入队列保证全部执行，但不能保证全部执行成功(不支持回滚)

一致性：数据前后一致

事务可能出错的3个地方:

1.入队错误：拒绝执行入队错误的命令，保证数据一致性

2.执行错误：事务执行出错的命令不会对数据库造成任何修改，保证数据一致性

3.服务器宕机：无持久化和持久化都会保证数据一致性

隔离性：单线程执行事务

持久性：由Redis持有化功能决定(AOF和RDB)

AOF的always可以保证持久性，而erverysec和no不能保证

RDB不能保证

## 主从复制

主服务器读写，从服务器读

主从复制过程 

第一次同步 全量复制

使用replicaof命令 

+ 建立链接 pssyns命令，携带两个参数runid 、offset（-1）
+ 同步数据 ：生成RDB、写命令会记录在 replication buffer缓冲区
+ 发送写操作命令

增量复制

环形缓冲区repl_baklog，利用主服务器和从服务器的offset差进行增量同步。

## 哨兵

监控

判断主节点是否故障，哨兵每隔一秒发送一个ping命令给主节点，主节点响应哨兵。

如果没有收到响应，哨兵就会主观认为主节点下线。发送命令给其他哨兵，进行投票，超过一定的值（一般设置为哨兵数量的一半 + 1）就会认为主节点客观下线。然后开始选取新的主节点。

选主节点

从候选者中选出主节点（认为主节点下线的哨兵），哨兵会向其他哨兵发送命令表示自己想候选主节点

拿到一半以上的赞成，并且大于客观下线的那个值。

同时有多个哨兵进行选举，会给自己投一票，其他节点根据选举策略（有好多种）进行投票。

## 分片集群

将数据分布在不同的服务器上。一个切片集群一共有16384个hash槽，每个数据根据key映射到1个hash槽。

根据key，使用CRC16算法生成一个16bit的值，再对16384取余数。
